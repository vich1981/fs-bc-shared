### Задача 4: Поиск самого быстрого сервера для загрузки

**Контекст:**

Представь, что ты разрабатываешь приложение для скачивания файлов, похожее на торрент-клиент или менеджер загрузок. Чтобы ускорить загрузку, приложение может пытаться скачать файл одновременно с нескольких серверов (зеркал) и использовать тот, который ответит первым. Твоя задача — симулировать этот процесс: запустить "запросы" к трем разным серверам и определить, какой из них "ответил" быстрее всех.

**Что нужно сделать:**

1. Создай три функции, имитирующие запрос к разным серверам. Каждая возвращает `Promise`:
    ◦ `queryServer1()`: Разрешается через случайное время от 500 до 1500 мс со строкой "Ответ от сервера 1".
    ◦ `queryServer2()`: Разрешается через случайное время от 500 до 1500 мс со строкой "Ответ от сервера 2".
    ◦ `queryServer3()`: Разрешается через случайное время от 500 до 1500 мс со строкой "Ответ от сервера 3".
    ◦ Используй `setTimeout` и `Math.random()` для генерации случайной задержки в указанном диапазоне.
2. Используй ``Promise.race()``, чтобы запустить все три запроса одновременно.
3. Когда первый из промисов успешно завершится, выведи в консоль его результат (строку с именем ответившего сервера) и сообщение "Используем этот сервер для загрузки!".
4. Добавь `console.log("Ищем самый быстрый сервер...")` перед запуском ``Promise.race()``.

**Почему задача полезна?**

``Promise.race()`` полезен в ситуациях, когда у тебя есть несколько источников данных или несколько способов выполнить задачу, и тебе нужен результат от самого быстрого из них. Классический пример — поиск ближайшего или наименее загруженного сервера (как в задаче). Другой пример: установка тайм-аута для асинхронной операции. Можно запустить `Promise.race()` с двумя промисами: один выполняет основную операцию, а второй — это промис, который отклоняется (`reject`) через определенное время (созданный с помощью `setTimeout`). Если основная операция не успевает завершиться до тайм-аута, `Promise.race()` завершится с ошибкой тайм-аута. Это позволяет контролировать максимальное время ожидания ответа.

**Подсказки:**

1. Вспомни, как работает `Promise.race()`. Чем он отличается от `Promise.all()`? Какой результат он возвращает? Как сгенерировать случайное число в диапазоне?
2. Для генерации случайной задержки используй `Math.random() * 1000 + 500`. Не забудь обернуть `setTimeout` в `new Promise()`. Передай массив вызовов функций (промисов) в `Promise.race([...])`.
3. Используй `.then()` после `Promise.race()`. Колбэк в `.then()` получит результат только самого первого завершившегося промиса. Выведи этот результат и дополнительное сообщение.
